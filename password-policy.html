<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Password policy guide based on NIST guidelines - password length vs complexity, MFA best practices, and secure authentication recommendations.">
    <meta name="keywords" content="password policy, NIST password guidelines, MFA best practices, password complexity, password length, secure authentication">
    <title>Password Policy Guide - RmVuln</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div class="container">
            <a href="index.html" style="text-decoration: none; color: inherit;"><h1>RmVuln</h1></a>
            <p class="tagline">Password Policy Guide</p>
        </div>
    </header>

    <main class="container">
        <a href="index.html" class="back-link">&larr; Back to Home</a>

        <section class="intro">
            <h2>Modern Password Policy Standards</h2>
            <p>Updated password guidance based on NIST SP 800-63B and industry best practices. Focus on length over complexity, eliminate outdated requirements, and implement strong authentication.</p>
        </section>

        <!-- NIST Guidelines -->
        <section class="vulnerability-card">
            <h2>NIST SP 800-63B Password Guidelines</h2>

            <h3>What NIST Recommends</h3>
            <table class="styled-table">
                <thead>
                    <tr>
                        <th>Recommendation</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Minimum Length</td>
                        <td>8 characters minimum, 15+ recommended</td>
                    </tr>
                    <tr>
                        <td>Maximum Length</td>
                        <td>At least 64 characters should be allowed</td>
                    </tr>
                    <tr>
                        <td>Character Types</td>
                        <td>Allow ALL printable ASCII, Unicode, spaces</td>
                    </tr>
                    <tr>
                        <td>Passphrases</td>
                        <td>Encourage use of passphrases over complex passwords</td>
                    </tr>
                    <tr>
                        <td>Blocklist</td>
                        <td>Check against breached password databases</td>
                    </tr>
                    <tr>
                        <td>No Expiration</td>
                        <td>Don't force periodic password changes</td>
                    </tr>
                    <tr>
                        <td>No Hints</td>
                        <td>Don't allow password hints or knowledge-based questions</td>
                    </tr>
                </tbody>
            </table>

            <h3>What NIST Says to AVOID</h3>
            <div class="remediation">
                <ul>
                    <li><strong>Composition rules</strong> - Don't require uppercase, lowercase, numbers, symbols</li>
                    <li><strong>Mandatory rotation</strong> - Don't force password changes every 30/60/90 days</li>
                    <li><strong>Security questions</strong> - Don't use "What's your mother's maiden name?"</li>
                    <li><strong>SMS-only 2FA</strong> - SMS is vulnerable to SIM swapping</li>
                    <li><strong>Password hints</strong> - These leak information about passwords</li>
                    <li><strong>Truncation</strong> - Don't silently truncate passwords</li>
                </ul>
            </div>
        </section>

        <!-- Length vs Complexity -->
        <section class="vulnerability-card">
            <h2>Length vs Complexity: The Math</h2>

            <h3>Password Entropy Comparison</h3>
            <table class="styled-table">
                <thead>
                    <tr>
                        <th>Password Type</th>
                        <th>Example</th>
                        <th>Entropy (bits)</th>
                        <th>Time to Crack*</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>8 char complex</td>
                        <td>P@ssw0rd</td>
                        <td>~52 bits</td>
                        <td>Minutes (common)</td>
                    </tr>
                    <tr>
                        <td>8 char random</td>
                        <td>kX9#mL2@</td>
                        <td>~52 bits</td>
                        <td>Hours to days</td>
                    </tr>
                    <tr>
                        <td>12 char random</td>
                        <td>Tm5#kL9@pQ2x</td>
                        <td>~78 bits</td>
                        <td>Years</td>
                    </tr>
                    <tr>
                        <td>4-word passphrase</td>
                        <td>correct-horse-battery-staple</td>
                        <td>~44 bits</td>
                        <td>Months</td>
                    </tr>
                    <tr>
                        <td>6-word passphrase</td>
                        <td>correct-horse-battery-staple-purple-elephant</td>
                        <td>~77 bits</td>
                        <td>Centuries</td>
                    </tr>
                    <tr>
                        <td>16 char random</td>
                        <td>Tm5#kL9@pQ2xRv7!</td>
                        <td>~104 bits</td>
                        <td>Heat death of universe</td>
                    </tr>
                </tbody>
            </table>
            <p style="font-size: 0.9rem; color: #666;">*Assuming 100 billion guesses/second and offline attack</p>

            <h3>Why Length Wins</h3>
            <div class="code-block">
<pre><code># Entropy calculation
# Entropy = log2(character_set_size ^ password_length)

# 8 characters, 95 printable ASCII
entropy = log2(95^8) = ~52.6 bits

# 16 characters, 95 printable ASCII
entropy = log2(95^16) = ~105.2 bits

# Each additional character DOUBLES the keyspace
# Adding complexity requirements barely helps
# and makes passwords harder to remember</code></pre>
            </div>
        </section>

        <!-- MFA Best Practices -->
        <section class="vulnerability-card">
            <h2>Multi-Factor Authentication (MFA)</h2>

            <h3>MFA Methods Ranked by Security</h3>
            <table class="styled-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Method</th>
                        <th>Security</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>Hardware Security Key (FIDO2/WebAuthn)</td>
                        <td>Excellent</td>
                        <td>Phishing-resistant, YubiKey, Google Titan</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Passkeys</td>
                        <td>Excellent</td>
                        <td>Device-bound, phishing-resistant</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Authenticator App (TOTP)</td>
                        <td>Good</td>
                        <td>Google Authenticator, Authy, 1Password</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Push Notification</td>
                        <td>Good</td>
                        <td>Duo, Microsoft Authenticator</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>SMS/Voice OTP</td>
                        <td>Fair</td>
                        <td>Vulnerable to SIM swap, SS7 attacks</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>Email OTP</td>
                        <td>Fair</td>
                        <td>Only as secure as email account</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>Security Questions</td>
                        <td>Poor</td>
                        <td>Not true MFA, easily researched</td>
                    </tr>
                </tbody>
            </table>

            <h3>FIDO2/WebAuthn Implementation</h3>
            <div class="code-block">
<pre><code>// Register a new passkey (JavaScript)
async function registerPasskey() {
  const publicKeyCredentialCreationOptions = {
    challenge: new Uint8Array(32), // from server
    rp: {
      name: "My Application",
      id: "example.com"
    },
    user: {
      id: new Uint8Array(16), // user ID from server
      name: "user@example.com",
      displayName: "User Name"
    },
    pubKeyCredParams: [
      { alg: -7, type: "public-key" },   // ES256
      { alg: -257, type: "public-key" }  // RS256
    ],
    authenticatorSelection: {
      authenticatorAttachment: "platform",
      userVerification: "required",
      residentKey: "required"
    },
    timeout: 60000,
    attestation: "none"
  };

  const credential = await navigator.credentials.create({
    publicKey: publicKeyCredentialCreationOptions
  });

  // Send credential to server for storage
}</code></pre>
            </div>
        </section>

        <!-- Password Storage -->
        <section class="vulnerability-card">
            <h2>Secure Password Storage</h2>

            <h3>Hashing Algorithms (Best to Worst)</h3>
            <table class="styled-table">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Recommendation</th>
                        <th>Work Factor</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Argon2id</td>
                        <td>Preferred choice</td>
                        <td>m=65536, t=3, p=4</td>
                    </tr>
                    <tr>
                        <td>bcrypt</td>
                        <td>Excellent, widely supported</td>
                        <td>cost=12 minimum</td>
                    </tr>
                    <tr>
                        <td>scrypt</td>
                        <td>Good alternative</td>
                        <td>N=2^17, r=8, p=1</td>
                    </tr>
                    <tr>
                        <td>PBKDF2-SHA256</td>
                        <td>Acceptable if others unavailable</td>
                        <td>600,000+ iterations</td>
                    </tr>
                    <tr>
                        <td>SHA-256 (salted)</td>
                        <td>NOT RECOMMENDED</td>
                        <td>Too fast for passwords</td>
                    </tr>
                    <tr>
                        <td>MD5, SHA-1</td>
                        <td>NEVER USE</td>
                        <td>Broken, easily cracked</td>
                    </tr>
                </tbody>
            </table>

            <h3>Implementation Examples</h3>
            <div class="code-block">
<pre><code># Python - Using Argon2
from argon2 import PasswordHasher

ph = PasswordHasher(
    time_cost=3,
    memory_cost=65536,
    parallelism=4,
    hash_len=32,
    salt_len=16
)

# Hash password
hash = ph.hash("user_password")

# Verify password
try:
    ph.verify(hash, "user_password")
    if ph.check_needs_rehash(hash):
        # Update hash with new parameters
        new_hash = ph.hash("user_password")
except VerifyMismatchError:
    print("Invalid password")</code></pre>
            </div>

            <div class="code-block">
<pre><code># Node.js - Using bcrypt
const bcrypt = require('bcrypt');

const saltRounds = 12;

// Hash password
const hash = await bcrypt.hash(password, saltRounds);

// Verify password
const match = await bcrypt.compare(password, hash);</code></pre>
            </div>

            <div class="code-block">
<pre><code># PHP - Using password_hash (bcrypt by default)
// Hash
$hash = password_hash($password, PASSWORD_ARGON2ID, [
    'memory_cost' => 65536,
    'time_cost' => 4,
    'threads' => 3
]);

// Verify
if (password_verify($password, $hash)) {
    if (password_needs_rehash($hash, PASSWORD_ARGON2ID)) {
        // Rehash with updated parameters
    }
}</code></pre>
            </div>
        </section>

        <!-- Policy Implementation -->
        <section class="vulnerability-card">
            <h2>Policy Implementation Checklist</h2>

            <h3>Registration/Password Change</h3>
            <div class="remediation">
                <ul>
                    <li>Minimum 12 characters (8 absolute minimum)</li>
                    <li>Maximum at least 64 characters</li>
                    <li>Allow all Unicode characters including spaces</li>
                    <li>Check against breached password list (HaveIBeenPwned API)</li>
                    <li>Show real-time password strength meter</li>
                    <li>Don't allow username/email in password</li>
                    <li>Encourage passphrases with clear examples</li>
                </ul>
            </div>

            <h3>Breached Password Check</h3>
            <div class="code-block">
<pre><code># Check password against HaveIBeenPwned (k-anonymity)
import hashlib
import requests

def check_pwned(password):
    sha1 = hashlib.sha1(password.encode()).hexdigest().upper()
    prefix, suffix = sha1[:5], sha1[5:]

    response = requests.get(
        f'https://api.pwnedpasswords.com/range/{prefix}',
        headers={'Add-Padding': 'true'}
    )

    for line in response.text.splitlines():
        hash_suffix, count = line.split(':')
        if hash_suffix == suffix:
            return int(count)  # Found in breaches
    return 0  # Not found

# Usage
breach_count = check_pwned("password123")
if breach_count > 0:
    print(f"Password found in {breach_count} breaches!")</code></pre>
            </div>

            <h3>Account Security</h3>
            <div class="remediation">
                <ul>
                    <li>Require MFA for all accounts (hardware key preferred)</li>
                    <li>Rate limit login attempts (5 attempts per 15 minutes)</li>
                    <li>Implement account lockout with exponential backoff</li>
                    <li>Send notifications on password change/new device login</li>
                    <li>Provide recovery codes for MFA backup</li>
                    <li>Log all authentication events</li>
                    <li>Implement secure password reset flow</li>
                </ul>
            </div>
        </section>

        <!-- Quick Reference -->
        <section class="vulnerability-card">
            <h2>Password Policy Quick Reference</h2>
            <table class="styled-table">
                <thead>
                    <tr>
                        <th>Setting</th>
                        <th>Recommended Value</th>
                        <th>Rationale</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Minimum length</td>
                        <td>12-15 characters</td>
                        <td>Entropy over complexity</td>
                    </tr>
                    <tr>
                        <td>Maximum length</td>
                        <td>64-128 characters</td>
                        <td>Support passphrases</td>
                    </tr>
                    <tr>
                        <td>Complexity rules</td>
                        <td>None required</td>
                        <td>NIST recommends against</td>
                    </tr>
                    <tr>
                        <td>Expiration</td>
                        <td>None (or 1 year max)</td>
                        <td>Only on breach detection</td>
                    </tr>
                    <tr>
                        <td>History</td>
                        <td>Last 10-24 passwords</td>
                        <td>Prevent reuse</td>
                    </tr>
                    <tr>
                        <td>Lockout threshold</td>
                        <td>5-10 attempts</td>
                        <td>Prevent brute force</td>
                    </tr>
                    <tr>
                        <td>Lockout duration</td>
                        <td>15-30 min or exponential</td>
                        <td>Slow down attacks</td>
                    </tr>
                    <tr>
                        <td>MFA requirement</td>
                        <td>Required for all</td>
                        <td>Defense in depth</td>
                    </tr>
                    <tr>
                        <td>Hashing algorithm</td>
                        <td>Argon2id or bcrypt</td>
                        <td>Memory-hard, slow</td>
                    </tr>
                    <tr>
                        <td>Breach checking</td>
                        <td>On every change</td>
                        <td>Prevent known passwords</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="cta">
            <h2>Need Detailed Password Security Guides?</h2>
            <p>For comprehensive tutorials and implementation guides:</p>
            <a href="https://fixthevuln.com" class="cta-button" target="_blank">Visit FixTheVuln.com &rarr;</a>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2026 RmVuln. Quick reference for security professionals.</p>
            <p><a href="index.html">Home</a> | <a href="https://fixthevuln.com" target="_blank">FixTheVuln.com</a></p>
        </div>
    </footer>
</body>
</html>
